PEP: 483
Title: The Theory of Type Hints
Version: $Revision$
Last-Modified: $Date$
Author: Guido van Rossum <guido@python.org>
Discussions-To: Python-Ideas <python-ideas@python.org>
Status: Draft
Type: Informational
Content-Type: text/x-rst
Created: 19-Dec-2014
Post-History:
Resolution:

Abstract
========

This PEP lays out the theory referenced by PEP 484.


Introduction
============

This document lays out the theory of the new type hinting proposal for
Python 3.5. It's not quite a full proposal or specification because
there are many details that need to be worked out, but it lays out the
theory without which it is hard to discuss more detailed specifications.
We start by recalling basic concepts of type theory; then we explain
gradual typing; then we state some general rules and
define the new special types (such as ``Union``) that can be used
in annotations; and finally we define the approach to generic types
and pragmatic aspects of type hinting.
(TODO: The section on generics needs more fleshing out; sorry!)


Notational conventions
----------------------

-  ``t1``, ``t2``, etc. and ``u1``, ``u2``, etc. are types. Sometimes we write
   ``ti`` or ``tj`` to refer to "any of ``t1``, ``t2``, etc."
-  ``T``, ``U`` etc. are type variables (defined with ``TypeVar()``, see below).
-  Objects, classes defined with a class statement, and instances are
   denoted using standard PEP 8 conventions.
-  the symbol ``==`` applyed to types in the context of this PEP means that
   two expressions represent the same type.
-  Note that PEP 484 makes a distinction between types and classes
   (a type is a concept for the type checker,
   while a class is a runtime concept).  In this PEP we clarify
   this distinction but avoid unnecessary strictness to allow more
   flexibility in the implementation of type checkers.


Background
==========

There are many definions of the concept of *type* in the literature.
Here we assume that type is a set of values and a set of functions that
one can apply to these values. Note that such definotion
could have mathematical problems such as Russel's paradox
because the two above sets could be "too infinite".
Nevertheless it is a good practical mental model.

There are several ways to define a particular type:

- By explicitely listing all values, e.g., ``{True, False}`` and logical
  operations on them represent a type ``bool``.
- By listing possible functions that can be applied to variables of
  given type, e.g., all objects that have an ``__int__`` method form a type.
- By special constructs such as class definitions, for example::

    class UserID(int):
        pass

  and a type is defined as the set of all objects that have
  ``isinstance(obj, UserID) == True``.
- There are more complex types, e.g., a type defined as
  all lists containing only ``int``, ``str`` or their subclasses,
  so that ``[1, 'abc', UserID(42)]`` has such type.

It is imortant to be able to systematically express types. If all types
could be represented by finite sets of values, one could do this
using set comprehensions::

  subset = {element in a_set if condition(element)}

and other regular set constructs. But sets of type values could be infinite,
and a special mechanism, often called a type system, for expressing types
is needed. The goal of this PEP is to describe a possible
type system for Python.

Type systems are needed for speed up, avoiding bugs, and even documentation
Here we focus on avoiding bugs. The crucial notion for this is a subtype.
Example ``first_var`` is ``firrts_type``, ``second_var`` is ``second_type``
when it is safe to assign ``first_var = second_var``?

There are many runtime cases when this *could* work, but a criteria when it
*should* work is when every value from ``second_type`` is also a member
of ``first_type``, this is called a subtype and is very close to subset.

Subtype is smaller but the set of actions is larger.
An example: less ints that floats but ints has e.g. bitwise shift.
Second example: IntList is not a subtype of FloatList, smaller value set, but
also smaller functions set (you can only append ``int`` to an ``IntList``).

There are two popular approaches to subtyping.
In nominal subtyping, type tree is based on the declared class tree,
i.e., ``UserID`` is considered a subtype of ``int``.
This approach should be used with care, because in Python
one can override attributes in incompatible way::

  class Base:
      answer = '42' # type: str
  class Derived(Base):
      answer = 5 # should be marked as error by type checker

In structural subtyping only set of methods is important,
i.e., ``UserID`` and ``int`` considered the same type.
accidental type confusion.
We strive to provide a support for both.


Types vs Classes
----------------

Class is object factory, a runtime concept. Types have been defined above.

Every class represents a type via ``isinstane``, but vice versa is
quite difficult, e.g. the example with list above could be implemented
by a class with runtime instance checks in constructor, but most importantly
we do not need this.

The static type API for type checkers described here should be used in
addition to existing class system where wanted.

We want to have good points from both worlds (dynamic and static),
below we describe how to type annotate only part of a program.

Typing interface is implemented with classes, i.e., at runtime it is possible
to ask ``Generic[T].__bases__``, but to emphasize the distiction between
classes (runtime types, defined by ``class`` statement,
and returned by ``type(obj)``) and types (static types constructed
using fundamental building blocks and used by a type checker)
special rules (see below) apply that indicate misunderstandings
by raising ``TypeError``.


Summary of gradual typing
=========================

We define a new relationship, is-consistent-with, which is similar to
is-subtype-of, except it is not transitive when the new type ``Any`` is
involved. (Neither relationship is symmetric.) Assigning ``a_value``
to ``a_variable`` is OK if the type of ``a_value`` is consistent with
the type of ``a_variable``. (Compare this to "... if the type of ``a_value``
is a subtype of the type of ``a_variable``", which states one of the
fundamentals of OO programming.) The is-consistent-with relationship is
defined by three rules:

-  A type ``t1`` is consistent with a type ``t2`` if ``t1`` is a
   subtype of ``t2``. (But not the other way around.)
-  ``Any`` is consistent with every type. (But ``Any`` is not a subtype
   of every type.)
-  Every type is a subtype of ``Any``. (Which also makes every type
   consistent with ``Any``, via rule 1.)

That's all! See Jeremy Siek's blog post `What is Gradual
Typing <http://wphomes.soic.indiana.edu/jsiek/what-is-gradual-typing/>`_
for a longer explanation and motivation. Note that rule 3 places ``Any``
at the root of the type graph. This makes it very similar to
``object``. The difference is that ``object`` is not consistent with
most types (e.g. you can't use an ``object()`` instance where an
``int`` is expected). IOW both ``Any`` and ``object`` mean
"any type is allowed" when used to annotate an argument, but only ``Any``
can be passed no matter what type is expected (in essence, ``Any`` shuts
up complaints from the static checker).

Here's an example showing how these rules work out in practice:

Say we have an ``Employee`` class, and a subclass ``Manager``::

  class Employee: ...
  class Manager(Employee): ...

Let's say variable ``worker`` is declared with type ``Employee``::

  worker = Employee()  # type: Employee

Now it's okay to assign a ``Manager`` instance to ``worker`` (rule 1)::

  worker = Manager()

It's not okay to assign an ``Employee`` instance to a variable declared with
type ``Manager``::

  boss = Manager()  # type: Manager
  boss = Employee()  # Fails static check

However, suppose we have a variable whose type is ``Any``::

  something = some_func()  # type: Any

Now it's okay to assign ``something`` to ``worker`` (rule 2)::

  worker = something  # OK

Of course it's also okay to assign ``worker`` to ``something`` (rule 3),
but we didn't need the concept of consistency for that::

  something = worker  # OK


General rules for using types
-----------------------------

Although all types are implemented using classes, the following
general rules apply to emphasize the distiction between types and classes:

-  No types defined below (i.e. ``Any``, ``Union``, etc.) can be instantiated,
   an attempt to do so will raise ``TypeError``.
   (But non-abstract subclasses of ``Generic`` can be.)
-  No types defined below can be subclassed, except for ``Generic`` and
   classes derived from it.
-  All of these will raise ``TypeError`` if they appear
   in ``isinstance`` or ``issubclass``.


Fundamental building blocks
---------------------------

-  **Any**. Every type is a subtype of ``Any``; however, to the static
   type checker it is also consistent with every type (see above).
-  **Union[t1, t2, ...]**. Types that are subtype of at least one of
   ``t1`` etc. are subtypes of this.

   *  Unions whose components are all subtypes of ``t1`` etc. are subtypes
      of this.
      Example: ``Union[int, str]`` is a subtype of ``Union[int, float, str]``.
   *  The order of the arguments doesn't matter.
      Example: ``Union[int, str] == Union[str, int]``.
   *  If ``ti`` is itself a ``Union`` the result is flattened.
      Example: ``Union[int, Union[float, str]] == Union[int, float, str]``.
   *  If ``ti`` and ``tj`` have a subtype relationship,
      the less specific type survives.
      Example: ``Union[Employee, Manager] == Union[Employee]``.
   *  ``Union[t1]`` returns just ``t1``. ``Union[]`` is illegal,
      so is ``Union[()]``
   *  Corollary: ``Union[..., Any, ...]`` returns ``Any``;
      ``Union[..., object, ...]`` returns ``object``; to cut a
      tie, ``Union[Any, object] == Union[object, Any] == Any``.

-  **Optional[t1]**. Alias for ``Union[t1, None]``, i.e. ``Union[t1,
   type(None)]``.
-  **Tuple[t1, t2, ..., tn]**. A tuple whose items are instances of ``t1``,
   etc. Example: ``Tuple[int, float]`` means a tuple of two items, the
   first is an ``int``, the second is a ``float``; e.g., ``(42, 3.14)``.

   *  ``Tuple[u1, u2, ..., um]`` is a subtype of ``Tuple[t1, t2, ..., tn]``
      if they have the same length ``n==m`` and each ``ui``
      is a subtype of ``ti``.
   *  To spell the type of the empty tuple, use ``Tuple[()]``.
   *  A variadic homogeneous tuple type can be written ``Tuple[t1, ...]``.
      (That's three dots, a literal ellipsis;
      and yes, that's a valid token in Python's syntax.)

-  **Callable[[t1, t2, ..., tn], tr]**. A function with positional
   argument types ``t1`` etc., and return type ``tr``. The argument list may be
   empty ``n==0``. There is no way to indicate optional or keyword
   arguments, nor varargs, but you can say the argument list is entirely
   unchecked by writing ``Callable[..., tr]`` (again, a literal ellipsis).

We might add:

-  **Intersection[t1, t2, ...]**. Types that are subtype of *each* of
   ``t1``, etc are subtypes of this. (Compare to ``Union``, which has *at
   least one* instead of *each* in its definition.)

   *  The order of the arguments doesn't matter. Nested intersections
      are flattened, e.g. ``Intersection[int, Intersection[float, str]]
      == Intersection[int, float, str]``.
   *  An intersection of fewer types is a supertype of an intersection of
      more types, e.g. ``Intersection[int, str]`` is a supertype
      of ``Intersection[int, float, str]``.
   *  An intersection of one argument is just that argument,
      e.g. ``Intersection[int]`` is ``int``.
   *  When argument have a subtype relationship, the more specific type
      survives, e.g. ``Intersection[str, Employee, Manager]`` is
      ``Intersection[str, Manager]``.
   *  ``Intersection[]`` is illegal, so is ``Intersection[()]``.
   *  Corollary: ``Any`` disappears from the argument list, e.g.
      ``Intersection[int, str, Any] == Intersection[int, str]``.
      ``Intersection[Any, object]`` is ``object``.
   *  The interaction between ``Intersection`` and ``Union`` is complex but
      should be no surprise if you understand the interaction between
      intersections and unions in set theory (note that sets of types can be
      infinite in size, since there is no limit on the number
      of new subclasses).


Generic types
=============

TODO: Explain motivation, generics as functors (but avoid this word),
examples, necessity of type variables, generic functions and declaration
syntax that described below.


Type variables
--------------

(TODO: Explain more. See also the `mypy docs on
generics <http://mypy.readthedocs.io/en/latest/generics.html>`_.)

- ``X = TypeVar('X')``. Declares a unique type variable. The name must match
  the variable name.

- ``Y = TypeVar('Y', t1, t2, ...)``. Ditto, constrained to ``t1``, etc. Behaves
  like ``Union[t1, t2, ...]`` for most purposes, but when used as a type
  variable, subclasses of ``t1``, etc. are replaced by the most-derived base
  class among ``t1``, etc. (TODO: reformulate this)

- Example of constrained type variables::

    S = TypeVar('S', str, bytes)

    def longest(first: S, second: S) -> S:
        return first if len(first) >= len(second) else second

    result = longest('a', 'abc')  # The inferred type for result is str

    result = longest('a', b'abc')  # Fails static type check

  In this example, both arguments to ``longest()`` must have the same type
  (``str`` or ``bytes``), and moreover, even if the arguments are instances
  of a common ``str`` subclass, the return type is still ``str``, not that
  subclass (see next example).

- For comparison, if the type variable was unconstrained, the common
  subclass would be chosen as the return type, e.g.::

    S = TypeVar('S')

    def longest(first: S, second: S) -> S:
        return first if len(first) >= len(second) else second

    class MyStr(str): ...

    result = longest(MyStr('a'), MyStr('abc'))

  The inferred type of ``result`` is ``MyStr`` (whereas in the ``AnyStr`` example
  it would be ``str``).

- Also for comparison, if a ``Union`` is used, the return type also has to be
  a ``Union``::

    U = Union[str, bytes]

    def longest(first: U, second: U) -> U:
        return first if len(first) >= len(second) else second

    result = longest('a', 'abc')

  The inferred type of ``result`` is still ``Union[str, bytes]``, even though
  both arguments are ``str``.


Defining and using generic types
--------------------------------

- ``class MyGeneric(Generic[X, Y, ...]):`` ... Define a generic type
  ``MyGeneric`` over type variables ``X``, etc. ``MyGeneric`` itself becomes
  parameterizable, e.g. ``MyGeneric[int, str, ...]`` is a specific type with
  substitutions ``X->int``, etc.

- TODO: Explain use of generic types in function signatures. E.g.
  ``Sequence[X]``, ``Sequence[int]``, ``Sequence[Tuple[X, Y, Z]]``,
  and mixtures.
  Think about co\*variance. No gimmicks like deriving from
  ``Sequence[Union[int, str]]`` or ``Sequence[Union[int, X]]``.
  Add notes on indexed generics


Covariance and Contravariance
-----------------------------

TODO: Definition, declaring variance, example with functions,
covariant example with ``Tuple``, contravariant example with ``Callable``,
mutable types, why ``List`` is invariant.

One of the best examples to illustrate contravariance is callable type.
It is covariant in the return type, but contravariant in the
arguments. "Covariant" here means that for two callable types that
differ only in the return type, the subtype relationship for the
callable types follows that of the return types. (Example:
``Callable[[], Manager]`` is a subtype of ``Callable[[], Employee]``.)
"Contravariant" here means that for two callable types that differ
only in the type of one argument, the subtype relationship for the
callable types goes in the opposite direction as for the argument
types. (Example: ``Callable[[Employee], None]`` is a subtype of
``Callable[[Manager], None]``. Yes, you read that right.)



Pragmatics
==========

Some things are irrelevant to the theory but make practical use more
convenient. (This is not a full list; I probably missed a few and some
are still controversial or not fully specified.)

-  Where a type is expected, ``None`` can be substituted for ``type(None)``;
   e.g. ``Union[t1, None] == Union[t1, type(None)]``.

- Type aliases, e.g.::

    Point = Tuple[float, float]
    def distance(point: Point) -> float: ...

- Forward references via strings, e.g.::

    class MyComparable:
        def compare(self, other: 'MyComparable') -> int: ...

- If a default of ``None`` is specified, the type is implicitly
  ``Optional``, e.g.::

    def get(key: KT, default: VT = None) -> VT: ...

- Type variables can be declared in unconstrained, constrained,
  or bounded form. The variance of a generic type can also
  be indicaded using a type variable declared with special keyword
  arguments, thus avoiding any special syntax, e.g.::

    T = TypeVar('T', bound=complex)

    def add(x: T, y: T) -> T:
        return x + y

    T_co = TypeVar('T_co', covariant=True)

    class ImmutableList(Generic[T_co]): ...

- Type declaration in comments, e.g.::

    lst = []  # type: Sequence[int]

- Casts using ``cast(T, obj)``, e.g.::

    zork = cast(Any, frobozz())

- Other things, e.g. overloading and stub modules, see PEP 484.


Predefined generic types and Protocols in typing.py
---------------------------------------------------

(See also the `typing.py module
<https://github.com/python/typing/blob/master/src/typing.py>`_.)

-  Everything from collections.abc (but Set renamed to AbstractSet).
-  Dict, List, Set, FrozenSet, a few more.
-  re.Pattern[AnyStr], re.Match[AnyStr].
-  re.IO[AnyStr], re.TextIO ~ re.IO[str], re.BinaryIO ~ re.IO[bytes].


Copyright
=========

This document is licensed under the `Open Publication License`_.


References and Footnotes
========================

.. _Open Publication License: http://www.opencontent.org/openpub/



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
